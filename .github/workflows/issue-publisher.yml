name: Publish Issues

on:
  push:
    paths:
      - 'issues/*.md'

permissions:
  contents: write  # 修改为write以允许提交更改
  issues: write

jobs:
  issue-publisher:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 2  # 确保获取足够的历史记录比较变更

      - name: 📂 获取本次提交变更的 issues/*.md 文件
        id: get_changed_files
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "🔍 当前 GITHUB_SHA: $GITHUB_SHA"

          # 获取前一次提交的SHA
          PREVIOUS_SHA=$(git rev-parse HEAD~1)
          echo "🔧 前一次提交 SHA: $PREVIOUS_SHA"

          # 处理删除的文件 - 使用单独命令获取删除的文件
          echo "📋 获取删除的文件..."
          git diff --diff-filter=D --name-only $PREVIOUS_SHA $GITHUB_SHA | while read -r file; do
            echo "检查删除文件: $file"
            # 移除可能的引号
            file=$(echo "$file" | sed 's/^"//;s/"$//')
            # 解码转义序列
            decoded_file=$(printf '%b' "$file")
            echo "解码后的文件路径: $decoded_file"
            
            if [[ "$decoded_file" == issues/* && "$decoded_file" == *.md ]]; then
              echo "🗑️ 检测到删除的md文件: $decoded_file"
              # 保存到删除文件列表
              echo "$decoded_file" >> /tmp/deleted_md_files.txt
            fi
          done
          
          # 如果删除文件列表存在，读取它
          DELETED_MD_FILES=""
          if [[ -f "/tmp/deleted_md_files.txt" ]]; then
            DELETED_MD_FILES=$(cat /tmp/deleted_md_files.txt)
          fi
          echo "📂 删除的md文件: $DELETED_MD_FILES"
          
          # 检查是否有删除操作
          DELETE_PERFORMED=false
          
          if [[ -n "$DELETED_MD_FILES" ]]; then
            # 处理每个删除的文件
            while IFS= read -r FILE; do
              echo "🔍 处理删除的文件：$FILE"
              
              # 从文件名获取标题
              FILENAME=$(basename "$FILE")
              TITLE="${FILENAME%.md}"
              echo "📋 从文件名提取标题：$TITLE"
              
              # 查找标题对应的issue
              ISSUE_NUMBER=$(gh issue list --state all --search "$TITLE in:title" --json number,title | jq -r ".[] | select(.title==\"$TITLE\") | .number")
              echo "查找issue结果: $ISSUE_NUMBER"
              
              if [[ -n "$ISSUE_NUMBER" ]]; then
                echo "🗑️ 找到对应issue #$ISSUE_NUMBER，准备关闭..."
                
                # GitHub API不支持直接删除issue，改为使用gh CLI将issue关闭(不锁定)
                echo "📌 关闭issue..."
                gh issue close "$ISSUE_NUMBER" --reason "completed" --comment "此issue对应的文件已被删除，自动关闭。"
                
                echo "✅ 已完成issue #$ISSUE_NUMBER 的处理"
                DELETE_PERFORMED=true
              else
                echo "⚠️ 未找到与'$TITLE'对应的issue，无需删除"
              fi
            done < <(echo "$DELETED_MD_FILES")
          else
            echo "✅ 没有删除任何md文件"
          fi

          # 获取本次提交中新增或修改的文件 - 使用单独命令获取新增或修改的文件
          echo "📋 获取新增或修改的文件..."
          git diff --diff-filter=AM --name-only $PREVIOUS_SHA $GITHUB_SHA | while read -r file; do
            echo "检查新增/修改文件: $file"
            # 移除可能的引号
            file=$(echo "$file" | sed 's/^"//;s/"$//')
            # 解码转义序列
            decoded_file=$(printf '%b' "$file")
            echo "解码后的文件路径: $decoded_file"
            
            if [[ "$decoded_file" == issues/* && "$decoded_file" == *.md ]]; then
              echo "📝 检测到新增或修改的md文件: $decoded_file"
              # 保存到修改文件列表
              echo "$decoded_file" >> /tmp/modified_md_files.txt
            fi
          done
          
          # 如果修改文件列表存在，读取它
          MODIFIED_MD_FILES=""
          if [[ -f "/tmp/modified_md_files.txt" ]]; then
            MODIFIED_MD_FILES=$(cat /tmp/modified_md_files.txt)
          fi
          echo "📂 新增或修改的md文件: $MODIFIED_MD_FILES"
          
          # 如果只执行了删除操作，并且没有任何新增或修改的md文件，则中止程序
          if [[ "$DELETE_PERFORMED" == "true" && -z "$MODIFIED_MD_FILES" ]]; then
            echo "✅ 已完成删除操作，没有新增或修改的md文件，中止程序"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 如果没有需要处理的文件，则中止程序
          if [[ -z "$MODIFIED_MD_FILES" ]]; then
            echo "✅ 本次提交没有新增或修改的md文件，中止程序"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 检查issues目录是否存在
          if [[ ! -d "issues" ]]; then
            echo "⚠️ issues目录不存在，可能已被删除"
            echo "✅ 处理完毕，退出"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 将新增或修改的md文件写入文件列表 - 确保文件真实存在
          > /tmp/final_md_files.txt
          while IFS= read -r file; do
            if [[ -f "$file" ]]; then
              echo "$file" >> /tmp/final_md_files.txt
              echo "✅ 确认文件存在: $file"
            else
              echo "⚠️ 文件不存在，跳过: $file"
            fi
          done < <(echo "$MODIFIED_MD_FILES")
          
          # 检查最终文件列表是否为空
          if [[ ! -s "/tmp/final_md_files.txt" ]]; then
            echo "⚠️ 所有文件均不存在，中止程序"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 设置环境变量指向文件列表
          echo "ISSUES_FILES_LIST=/tmp/final_md_files.txt" >> $GITHUB_ENV
          echo "HAS_MD_FILES=true" >> $GITHUB_ENV
          echo "📂 本次将处理的md文件: $(cat /tmp/final_md_files.txt)"

      - name: 📦 处理Markdown文件中的图片
        if: env.HAS_MD_FILES == 'true'
        run: |
          # 确保assets目录存在
          mkdir -p assets/images
          
          # 安装必要工具
          sudo apt-get update
          sudo apt-get install -y coreutils curl file imagemagick
          
          # 获取仓库基础URL
          REPO_URL="https://raw.githubusercontent.com/${{ github.repository }}/main"
          echo "仓库原始文件URL基础地址: $REPO_URL"
          
          # 创建文件映射表 - 用于追踪图片和它们所属的md文件
          > /tmp/image_file_map.txt
          
          # 清理旧图片
          while IFS= read -r FILE; do
            echo "开始处理文件 $FILE 的图片..."
            
            # 从文件名获取基本名称（不带扩展名）- 用于创建子目录
            BASE_NAME=$(basename "$FILE" .md)
            
            # 为每个文件创建独立的图片目录
            IMG_DIR="assets/images/$BASE_NAME"
            
            # 清理旧目录中的图片 (如果存在)
            if [[ -d "$IMG_DIR" ]]; then
              echo "清理旧图片目录: $IMG_DIR"
              rm -rf "$IMG_DIR"
            fi
            
            # 创建新的图片目录
            mkdir -p "$IMG_DIR"
            
            # 记录这个文件对应的图片目录
            echo "$FILE:$IMG_DIR" >> /tmp/image_file_map.txt
          done < "${{ env.ISSUES_FILES_LIST }}"
          
          # 遍历处理每个md文件中的图片
          while IFS= read -r FILE; do
            echo "处理文件 $FILE 中的图片"
            
            # 获取这个文件的图片目录
            IMG_DIR=$(grep "^$FILE:" /tmp/image_file_map.txt | cut -d':' -f2)
            if [[ -z "$IMG_DIR" ]]; then
              echo "⚠️ 无法找到 $FILE 的图片目录，使用默认目录"
              BASE_NAME=$(basename "$FILE" .md)
              IMG_DIR="assets/images/$BASE_NAME"
              mkdir -p "$IMG_DIR"
            fi
            
            # 暂存修改状态标志
            MODIFIED=false
            
            # 创建临时文件
            TMP_FILE=$(mktemp)
            
            # 提取文件中的所有图片标记
            IMAGE_TAGS=$(grep -o '!\[[^]]*\]([^)]\+)' "$FILE" || echo "")
            
            if [[ -n "$IMAGE_TAGS" ]]; then
              echo "检测到图片标记: $(echo "$IMAGE_TAGS" | wc -l)个"
              
              # 处理每个图片标记
              COUNT=1
              while IFS= read -r IMG_TAG; do
                # 提取链接部分
                IMG_URL=$(echo "$IMG_TAG" | grep -o '([^)]\+)' | tr -d '()')
                ALT_TEXT=$(echo "$IMG_TAG" | grep -o '!\[\([^]]*\)\]' | sed 's/!\[\(.*\)\]/\1/')
                
                echo "处理图片 #$COUNT: $IMG_URL"
                echo "图片替代文本: $ALT_TEXT"
                
                # 过滤掉已经指向仓库的图片链接
                if [[ "$IMG_URL" == *"$REPO_URL"* ]]; then
                  echo "图片已在仓库中，跳过: $IMG_URL"
                  COUNT=$((COUNT+1))
                  continue
                fi
                
                # 生成唯一的图片文件名(使用序号和原始URL的哈希)
                IMG_NAME=$(echo "$IMG_URL" | md5sum | cut -d' ' -f1)
                SAFE_FILENAME="${COUNT}_${IMG_NAME}"
                
                # 构建临时和最终文件路径
                TMP_IMG_PATH="/tmp/${SAFE_FILENAME}.tmp"
                
                echo "下载图片到临时文件: $TMP_IMG_PATH"
                # 下载图片到临时位置
                curl -s -L -A "Mozilla/5.0" -o "$TMP_IMG_PATH" "$IMG_URL" || true
                
                # 检查文件是否成功下载
                if [[ ! -s "$TMP_IMG_PATH" ]]; then
                  echo "⚠️ 下载失败，尝试添加引用头..."
                  curl -s -L -A "Mozilla/5.0" -H "Referer: $IMG_URL" -o "$TMP_IMG_PATH" "$IMG_URL" || true
                fi
                
                # 再次检查文件是否存在和大小
                if [[ ! -s "$TMP_IMG_PATH" ]]; then
                  echo "⚠️ 所有下载尝试均失败，跳过此图片"
                  COUNT=$((COUNT+1))
                  continue
                fi
                
                # 使用file命令检测文件类型
                FILE_TYPE=$(file -b --mime-type "$TMP_IMG_PATH")
                echo "检测到文件类型: $FILE_TYPE"
                
                # 确定最终扩展名
                case "$FILE_TYPE" in
                  image/jpeg)
                    EXT=".jpg"
                    ;;
                  image/png)
                    EXT=".png"
                    ;;
                  image/gif)
                    EXT=".gif"
                    ;;
                  image/webp)
                    EXT=".webp"
                    ;;
                  image/svg+xml)
                    EXT=".svg"
                    ;;
                  image/*)
                    # 默认给图片类型用.jpg
                    EXT=".jpg"
                    ;;
                  *)
                    # 对于非图片类型，尝试转换为PNG
                    echo "非图片类型 $FILE_TYPE，尝试转换为PNG"
                    convert "$TMP_IMG_PATH" "$TMP_IMG_PATH.png" || cp "$TMP_IMG_PATH" "$TMP_IMG_PATH.png"
                    
                    if [[ -s "$TMP_IMG_PATH.png" ]]; then
                      TMP_IMG_PATH="$TMP_IMG_PATH.png"
                      EXT=".png"
                    else
                      # 如果转换失败，使用默认扩展名
                      EXT=".jpg"
                    fi
                    ;;
                esac
                
                # 最终的图片文件路径
                FINAL_IMG_PATH="$IMG_DIR/${SAFE_FILENAME}${EXT}"
                
                # 移动图片到最终位置
                echo "保存图片到: $FINAL_IMG_PATH"
                mv "$TMP_IMG_PATH" "$FINAL_IMG_PATH"
                
                # 构建新的图片URL
                REPO_IMG_URL="$REPO_URL/$FINAL_IMG_PATH"
                echo "新图片URL: $REPO_IMG_URL"
                
                # 构建新的完整图片标记
                NEW_IMG_TAG="![$ALT_TEXT]($REPO_IMG_URL)"
                
                # 转义用于sed的特殊字符
                IMG_TAG_ESCAPED=$(echo "$IMG_TAG" | sed 's/[\/&]/\\&/g')
                NEW_IMG_TAG_ESCAPED=$(echo "$NEW_IMG_TAG" | sed 's/[\/&]/\\&/g')
                
                # 替换Markdown文件中的图片链接
                cat "$FILE" > "$TMP_FILE"
                sed -i "s|$IMG_TAG_ESCAPED|$NEW_IMG_TAG_ESCAPED|g" "$TMP_FILE"
                
                # 检查替换是否成功
                if cmp -s "$FILE" "$TMP_FILE"; then
                  echo "⚠️ 替换失败，尝试使用perl..."
                  cat "$FILE" > "$TMP_FILE"
                  perl -i -0 -pe "s|\Q$IMG_TAG\E|$NEW_IMG_TAG|g" "$TMP_FILE"
                  
                  if cmp -s "$FILE" "$TMP_FILE"; then
                    echo "⚠️ perl替换也失败，尝试原始URL直接替换..."
                    IMG_URL_ESCAPED=$(echo "$IMG_URL" | sed 's/[\/&]/\\&/g')
                    REPO_IMG_URL_ESCAPED=$(echo "$REPO_IMG_URL" | sed 's/[\/&]/\\&/g')
                    
                    cat "$FILE" > "$TMP_FILE"
                    sed -i "s|$IMG_URL_ESCAPED|$REPO_IMG_URL_ESCAPED|g" "$TMP_FILE"
                    
                    if cmp -s "$FILE" "$TMP_FILE"; then
                      echo "⚠️ 所有替换方法均失败，跳过此图片"
                      COUNT=$((COUNT+1))
                      continue
                    fi
                  fi
                fi
                
                # 写回Markdown文件
                cat "$TMP_FILE" > "$FILE"
                echo "✅ 成功替换图片链接: $IMG_URL -> $REPO_IMG_URL"
                MODIFIED=true
                COUNT=$((COUNT+1))
              done < <(echo "$IMAGE_TAGS")
            else
              echo "尝试使用备用方法检测图片链接..."
              # 另一种检测方法 - 针对特殊格式的图片链接
              IMAGE_LINKS=$(grep -o '!\[.*\](http[^)]*' "$FILE" | sed 's/!\[.*\](//' || echo "")
              
              if [[ -n "$IMAGE_LINKS" ]]; then
                echo "使用备用方式检测到 $(echo "$IMAGE_LINKS" | wc -l) 个图片链接"
                
                COUNT=1
                while IFS= read -r IMG_URL; do
                  echo "处理备用模式图片 #$COUNT: $IMG_URL"
                  
                  # 过滤掉已经指向仓库的图片链接
                  if [[ "$IMG_URL" == *"$REPO_URL"* ]]; then
                    echo "图片已在仓库中，跳过: $IMG_URL"
                    COUNT=$((COUNT+1))
                    continue
                  fi
                  
                  # 生成唯一的图片文件名
                  IMG_NAME=$(echo "$IMG_URL" | md5sum | cut -d' ' -f1)
                  SAFE_FILENAME="alt_${COUNT}_${IMG_NAME}"
                  
                  # 构建临时和最终文件路径
                  TMP_IMG_PATH="/tmp/${SAFE_FILENAME}.tmp"
                  
                  # 下载图片到临时位置
                  curl -s -L -A "Mozilla/5.0" -o "$TMP_IMG_PATH" "$IMG_URL" || true
                  
                  # 检查文件是否成功下载
                  if [[ ! -s "$TMP_IMG_PATH" ]]; then
                    echo "⚠️ 下载失败，尝试添加引用头..."
                    curl -s -L -A "Mozilla/5.0" -H "Referer: $IMG_URL" -o "$TMP_IMG_PATH" "$IMG_URL" || true
                  fi
                  
                  # 再次检查文件
                  if [[ ! -s "$TMP_IMG_PATH" ]]; then
                    echo "⚠️ 所有下载尝试均失败，跳过此图片"
                    COUNT=$((COUNT+1))
                    continue
                  fi
                  
                  # 使用file命令检测文件类型
                  FILE_TYPE=$(file -b --mime-type "$TMP_IMG_PATH")
                  echo "检测到文件类型: $FILE_TYPE"
                  
                  # 确定扩展名
                  case "$FILE_TYPE" in
                    image/jpeg)
                      EXT=".jpg"
                      ;;
                    image/png)
                      EXT=".png"
                      ;;
                    image/gif)
                      EXT=".gif"
                      ;;
                    image/webp)
                      EXT=".webp"
                      ;;
                    image/svg+xml)
                      EXT=".svg"
                      ;;
                    image/*)
                      # 默认图片扩展名
                      EXT=".jpg"
                      ;;
                    *)
                      # 对于非图片类型，尝试转换
                      echo "非图片类型 $FILE_TYPE，尝试转换为PNG"
                      convert "$TMP_IMG_PATH" "$TMP_IMG_PATH.png" || cp "$TMP_IMG_PATH" "$TMP_IMG_PATH.png"
                      
                      if [[ -s "$TMP_IMG_PATH.png" ]]; then
                        TMP_IMG_PATH="$TMP_IMG_PATH.png"
                        EXT=".png"
                      else
                        EXT=".jpg"
                      fi
                      ;;
                  esac
                  
                  # 最终的图片文件路径
                  FINAL_IMG_PATH="$IMG_DIR/${SAFE_FILENAME}${EXT}"
                  
                  # 移动图片到最终位置
                  echo "保存图片到: $FINAL_IMG_PATH"
                  mv "$TMP_IMG_PATH" "$FINAL_IMG_PATH"
                  
                  # 构建新的图片URL
                  REPO_IMG_URL="$REPO_URL/$FINAL_IMG_PATH"
                  echo "新图片URL: $REPO_IMG_URL"
                  
                  # 替换Markdown文件中的图片链接
                  IMG_URL_ESCAPED=$(echo "$IMG_URL" | sed 's/[\/&]/\\&/g')
                  REPO_IMG_URL_ESCAPED=$(echo "$REPO_IMG_URL" | sed 's/[\/&]/\\&/g')
                  
                  cat "$FILE" > "$TMP_FILE"
                  sed -i "s|$IMG_URL_ESCAPED|$REPO_IMG_URL_ESCAPED|g" "$TMP_FILE"
                  
                  # 检查替换是否成功
                  if cmp -s "$FILE" "$TMP_FILE"; then
                    echo "⚠️ 替换失败，尝试使用perl..."
                    cat "$FILE" > "$TMP_FILE"
                    perl -i -pe "s|\Q$IMG_URL\E|$REPO_IMG_URL|g" "$TMP_FILE"
                    
                    if cmp -s "$FILE" "$TMP_FILE"; then
                      echo "⚠️ 所有替换方法均失败，跳过此图片"
                      COUNT=$((COUNT+1))
                      continue
                    fi
                  fi
                  
                  # 写回Markdown文件
                  cat "$TMP_FILE" > "$FILE"
                  echo "✅ 成功替换图片链接: $IMG_URL -> $REPO_IMG_URL"
                  MODIFIED=true
                  COUNT=$((COUNT+1))
                done < <(echo "$IMAGE_LINKS")
              else
                echo "所有方法均未检测到图片链接，无需处理"
              fi
            fi
            
            # 清理临时文件
            rm -f "$TMP_FILE"
            
            if [[ "$MODIFIED" == "true" ]]; then
              echo "✅ 文件 $FILE 中的图片链接已更新"
            else
              echo "ℹ️ 文件 $FILE 无需修改或未检测到图片"
            fi
          done < "${{ env.ISSUES_FILES_LIST }}"
          
          # 检查是否有更改
          if [[ -n "$(git status --porcelain assets/images/)" || -n "$(git status --porcelain issues/)" ]]; then
            echo "👉 检测到更改，提交更新的图片和Markdown文件"
            
            # 验证GitHub Issue中的图片是否正确
            echo "✅ 验证处理后的Markdown文件..."
            
            # 重新检查所有处理过的Markdown文件
            while IFS= read -r FILE; do
              echo "检查文件: $FILE"
              
              # 确认所有图片链接都指向仓库
              REPO_LINKS_COUNT=$(grep -o "!\[.*\](${REPO_URL}[^)]\+)" "$FILE" | wc -l)
              EXTERNAL_LINKS_COUNT=$(grep -o '!\[.*\](http[^)]\+)' "$FILE" | grep -v "$REPO_URL" | wc -l)
              
              echo "仓库内链接: $REPO_LINKS_COUNT, 外部链接: $EXTERNAL_LINKS_COUNT"
              
              if [[ $EXTERNAL_LINKS_COUNT -gt 0 ]]; then
                echo "⚠️ 警告: 文件 $FILE 中仍有 $EXTERNAL_LINKS_COUNT 个外部图片链接"
              else
                echo "✓ 文件 $FILE 中的所有图片链接已指向仓库"
              fi
            done < "${{ env.ISSUES_FILES_LIST }}"
            
            # 配置Git
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            
            # 添加并提交更改
            git add assets/images/
            git add issues/
            git commit -m "🖼️ 将图片转储到仓库并更新Markdown链接" || echo "没有变更需要提交"
            
            # 推送更改
            git push
            
            echo "✅ 更改已提交并推送"
          else
            echo "✅ 没有检测到需要提交的更改"
          fi

      - name: 📄 处理每个md文件
        id: process_files
        if: env.HAS_MD_FILES == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 检查文件列表是否存在
          if [[ ! -f "${{ env.ISSUES_FILES_LIST }}" ]]; then
            echo "❌ 文件列表不存在，跳过处理"
            exit 0
          fi
          
          # 检查文件列表是否为空
          if [[ ! -s "${{ env.ISSUES_FILES_LIST }}" ]]; then
            echo "❌ 文件列表为空，跳过处理"
            exit 0
          fi
          
          echo "📂 读取md文件列表: $(cat ${{ env.ISSUES_FILES_LIST }})"
          
          # 先获取当前仓库已有的所有标签
          echo "📋 获取仓库现有标签..."
          EXISTING_LABELS=$(gh label list --json name | jq -r '.[].name')
          echo "📋 现有标签: $EXISTING_LABELS"
          
          # 遍历文件列表中的每个文件
          while IFS= read -r FILE; do
            echo "🔍 处理文件：$FILE"
            
            # 检查文件是否存在
            if [[ ! -f "$FILE" ]]; then
              echo "⚠️ 文件不存在：$FILE，跳过处理"
              continue
            fi
            
            # 从文件名获取标题（移除扩展名和路径）
            FILENAME=$(basename "$FILE")
            TITLE="${FILENAME%.md}"
            echo "📋 从文件名提取标题：$TITLE"
            
            # 从文件内容获取标签
            LABELS=$(grep -E '^ISSUE_LABELS:' "$FILE" | sed 's/^ISSUE_LABELS:[[:space:]]*//' || echo "文档")
            
            # 如果没有找到标签，使用默认标签
            if [[ -z "$LABELS" ]]; then
              LABELS="文档"
            fi
            echo "📋 提取标签：$LABELS"
            
            # 处理标签，将逗号分隔的标签转换为数组
            LABEL_ARRAY=()
            IFS=',' read -ra TEMP_ARRAY <<< "$LABELS"
            for label in "${TEMP_ARRAY[@]}"; do
              # 去除标签两端的空格
              LABEL_ARRAY+=("$(echo "$label" | xargs)")
            done
            echo "📋 解析的标签：${LABEL_ARRAY[*]}"
            
            # 确保标签在仓库中存在
            for label in "${LABEL_ARRAY[@]}"; do
              if ! echo "$EXISTING_LABELS" | grep -q "^$label$"; then
                echo "🏷️ 创建新标签: $label"
                # 创建标签，使用随机颜色
                COLORS=("fc8403" "2cbe4e" "0075ca" "d73a4a" "6f42c1" "fbca04" "b60205" "5319e7" "0e8a16" "1d76db" "c5def5" "bfdadc")
                RANDOM_COLOR=${COLORS[$((RANDOM % ${#COLORS[@]}))]}
                gh label create "$label" --color "$RANDOM_COLOR" || true
              else
                echo "🏷️ 标签已存在: $label"
              fi
            done
            
            # 从文件中提取正文内容（跳过标签行）
            # 将内容保存到临时文件，避免Shell命令注入和特殊字符问题
            grep -v '^ISSUE_LABELS:' "$FILE" > /tmp/issue_body.md
            echo "📋 提取正文内容长度：$(wc -c < /tmp/issue_body.md) 字节"

            # 检查是否已有同名 issue
            ISSUE_NUMBER=$(gh issue list --state all --search "$TITLE in:title" --json number,title,state | jq -r ".[] | select(.title==\"$TITLE\") | .number")
            
            # 如果找到 issue，则更新，否则创建新的 issue
            if [[ -n "$ISSUE_NUMBER" ]]; then
              # 获取issue状态
              ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --json state | jq -r '.state')
              echo "🔍 检查是否已有同名 issue: '$TITLE'，找到 issue number: $ISSUE_NUMBER，状态: $ISSUE_STATE"
              
              # 如果issue是关闭状态，先重新打开
              if [[ "$ISSUE_STATE" == "CLOSED" ]]; then
                echo "🔓 重新打开已关闭的issue #$ISSUE_NUMBER"
                gh issue reopen "$ISSUE_NUMBER"
              fi
              
              echo "♻️ 更新已存在的 issue #$ISSUE_NUMBER"
              
              # 更新issue内容
              gh issue edit "$ISSUE_NUMBER" --body-file /tmp/issue_body.md
              
              # 获取issue现有标签
              CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels | jq -r '.labels[].name')
              echo "🏷️ 现有标签: $CURRENT_LABELS"
              
              # 添加md文件中的新标签
              echo "🏷️ 添加新标签..."
              for label in "${LABEL_ARRAY[@]}"; do
                # 检查标签是否已存在于issue中
                if ! echo "$CURRENT_LABELS" | grep -q "^$label$"; then
                  echo "🏷️ 添加新标签: $label"
                  gh issue edit "$ISSUE_NUMBER" --add-label "$label"
                else
                  echo "🏷️ 标签已存在: $label"
                fi
              done
            else
              echo "🆕 创建新的 issue: $TITLE"
              
              # 创建一个临时文件包含标签参数
              LABEL_PARAMS=""
              for label in "${LABEL_ARRAY[@]}"; do
                LABEL_PARAMS+=" --label \"$label\""
              done
              
              # 使用body-file和标签创建issue
              eval "gh issue create -t \"$TITLE\" --body-file /tmp/issue_body.md $LABEL_PARAMS"
            fi

            echo "✅ 完成：$TITLE"
          done < "${{ env.ISSUES_FILES_LIST }}"