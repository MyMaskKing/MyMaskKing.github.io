name: Publish Issues

on:
  push:
    paths:
      - 'issues/*.md'

permissions:
  contents: read
  issues: write

jobs:
  issue-publisher:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 2  # 确保获取足够的历史记录比较变更

      - name: 📂 获取本次提交变更的 issues/*.md 文件
        id: get_changed_files
        run: |
          echo "🔍 当前 GITHUB_SHA: $GITHUB_SHA"

          # 获取前一次提交的SHA
          PREVIOUS_SHA=$(git rev-parse HEAD~1)
          echo "🔧 前一次提交 SHA: $PREVIOUS_SHA"

          # 步骤1: 获取git diff结果 - 删除的文件
          echo "📋 步骤1: 获取删除的文件..."
          # 直接保存删除的文件到临时文件，避免使用管道和grep处理中文路径
          git diff --diff-filter=D --name-only $PREVIOUS_SHA $GITHUB_SHA > /tmp/all_deleted_files.txt
          ALL_DELETED_FILES=$(cat /tmp/all_deleted_files.txt)
          echo "📂 所有删除的文件: $ALL_DELETED_FILES"
          
          # 手动检查每个删除的文件是否在issues目录下并以.md结尾
          DELETED_MD_FILES=""
          while IFS= read -r file; do
            if [[ "$file" == issues/* && "$file" == *.md ]]; then
              DELETED_MD_FILES="$DELETED_MD_FILES$file"$'\n'
              echo "📄 检测到删除的md文件: $file"
            fi
          done < /tmp/all_deleted_files.txt
          
          # 去除末尾的换行符
          DELETED_MD_FILES=$(echo "$DELETED_MD_FILES" | sed '/^$/d')
          echo "📂 删除的md文件: $DELETED_MD_FILES"
          
          # 检查是否有删除操作
          DELETE_PERFORMED=false
          
          if [[ -n "$DELETED_MD_FILES" ]]; then
            # 保存删除的文件列表
            echo "$DELETED_MD_FILES" > /tmp/deleted_files.txt
            
            # 处理每个删除的文件
            while IFS= read -r FILE; do
              echo "🔍 处理删除的文件：$FILE"
              
              # 从文件名获取标题
              FILENAME=$(basename "$FILE")
              TITLE="${FILENAME%.md}"
              echo "📋 从文件名提取标题：$TITLE"
              
              # 查找标题对应的issue
              ISSUE_NUMBER=$(gh issue list --state all --search "$TITLE in:title" --json number,title | jq -r ".[] | select(.title==\"$TITLE\") | .number")
              
              if [[ -n "$ISSUE_NUMBER" ]]; then
                echo "🗑️ 找到对应issue #$ISSUE_NUMBER，准备删除..."
                
                # 删除issue（使用GitHub REST API，因为CLI没有直接删除issue的功能）
                curl -X DELETE -H "Authorization: token ${{ github.token }}" \
                     -H "Accept: application/vnd.github.v3+json" \
                     "https://api.github.com/repos/${{ github.repository }}/issues/$ISSUE_NUMBER"
                
                echo "✅ 已成功删除issue #$ISSUE_NUMBER"
                DELETE_PERFORMED=true
              else
                echo "⚠️ 未找到与'$TITLE'对应的issue，无需删除"
              fi
            done < /tmp/deleted_files.txt
          else
            echo "✅ 没有删除任何md文件"
          fi

          # 获取本次提交中新增或修改的md文件
          echo "📋 获取本次提交中新增或修改的md文件..."
          git diff --diff-filter=AM --name-only $PREVIOUS_SHA $GITHUB_SHA > /tmp/all_modified_files.txt
          
          # 手动检查每个新增或修改的文件是否在issues目录下并以.md结尾
          MODIFIED_MD_FILES=""
          while IFS= read -r file; do
            if [[ "$file" == issues/* && "$file" == *.md ]]; then
              MODIFIED_MD_FILES="$MODIFIED_MD_FILES$file"$'\n'
              echo "📄 检测到新增或修改的md文件: $file"
            fi
          done < /tmp/all_modified_files.txt
          
          # 去除末尾的换行符
          MODIFIED_MD_FILES=$(echo "$MODIFIED_MD_FILES" | sed '/^$/d')
          echo "📂 本次提交中新增或修改的md文件: $MODIFIED_MD_FILES"
          
          # 如果只执行了删除操作，并且没有任何新增或修改的md文件，则中止程序
          if [[ "$DELETE_PERFORMED" == "true" && -z "$MODIFIED_MD_FILES" ]]; then
            echo "✅ 已完成删除操作，没有新增或修改的md文件，中止程序"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 如果没有新增或修改的md文件，则中止程序
          if [[ -z "$MODIFIED_MD_FILES" ]]; then
            echo "✅ 本次提交没有新增或修改的md文件，中止程序"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi

          # 检查issues目录是否存在
          if [[ ! -d "issues" ]]; then
            echo "⚠️ issues目录不存在，可能已被删除"
            echo "✅ 处理完毕，退出"
            echo "HAS_MD_FILES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 将新增或修改的md文件写入文件列表
          echo "$MODIFIED_MD_FILES" > /tmp/issues_files_list.txt
          echo "📂 待处理的md文件: $(cat /tmp/issues_files_list.txt)"
          
          # 设置环境变量指向文件列表
          echo "ISSUES_FILES_LIST=/tmp/issues_files_list.txt" >> $GITHUB_ENV
          echo "HAS_MD_FILES=true" >> $GITHUB_ENV

      - name: 📄 处理每个md文件
        id: process_files
        if: env.HAS_MD_FILES == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # 检查文件列表是否存在
          if [[ ! -f "${{ env.ISSUES_FILES_LIST }}" ]]; then
            echo "❌ 文件列表不存在，跳过处理"
            exit 0
          fi
          
          # 检查文件列表是否为空
          if [[ ! -s "${{ env.ISSUES_FILES_LIST }}" ]]; then
            echo "❌ 文件列表为空，跳过处理"
            exit 0
          fi
          
          echo "📂 读取md文件列表: $(cat ${{ env.ISSUES_FILES_LIST }})"
          
          # 先获取当前仓库已有的所有标签
          echo "📋 获取仓库现有标签..."
          EXISTING_LABELS=$(gh label list --json name | jq -r '.[].name')
          echo "📋 现有标签: $EXISTING_LABELS"
          
          # 遍历文件列表中的每个文件
          while IFS= read -r FILE; do
            echo "🔍 处理文件：$FILE"
            
            # 检查文件是否存在
            if [[ ! -f "$FILE" ]]; then
              echo "⚠️ 文件不存在：$FILE，跳过处理"
              continue
            fi
            
            # 从文件名获取标题（移除扩展名和路径）
            FILENAME=$(basename "$FILE")
            TITLE="${FILENAME%.md}"
            echo "📋 从文件名提取标题：$TITLE"
            
            # 从文件内容获取标签
            LABELS=$(grep -E '^ISSUE_LABELS:' "$FILE" | sed 's/^ISSUE_LABELS:[[:space:]]*//' || echo "documentation")
            
            # 如果没有找到标签，使用默认标签
            if [[ -z "$LABELS" ]]; then
              LABELS="documentation"
            fi
            echo "📋 提取标签：$LABELS"
            
            # 处理标签，将逗号分隔的标签转换为数组
            LABEL_ARRAY=()
            IFS=',' read -ra TEMP_ARRAY <<< "$LABELS"
            for label in "${TEMP_ARRAY[@]}"; do
              # 去除标签两端的空格
              LABEL_ARRAY+=("$(echo "$label" | xargs)")
            done
            echo "📋 解析的标签：${LABEL_ARRAY[*]}"
            
            # 确保标签在仓库中存在
            for label in "${LABEL_ARRAY[@]}"; do
              if ! echo "$EXISTING_LABELS" | grep -q "^$label$"; then
                echo "🏷️ 创建新标签: $label"
                # 创建标签，使用随机颜色
                COLORS=("fc8403" "2cbe4e" "0075ca" "d73a4a" "6f42c1" "fbca04" "b60205" "5319e7" "0e8a16" "1d76db" "c5def5" "bfdadc")
                RANDOM_COLOR=${COLORS[$((RANDOM % ${#COLORS[@]}))]}
                gh label create "$label" --color "$RANDOM_COLOR" || true
              else
                echo "🏷️ 标签已存在: $label"
              fi
            done
            
            # 从文件中提取正文内容（跳过标签行）
            # 将内容保存到临时文件，避免Shell命令注入和特殊字符问题
            grep -v '^ISSUE_LABELS:' "$FILE" > /tmp/issue_body.md
            echo "📋 提取正文内容长度：$(wc -c < /tmp/issue_body.md) 字节"

            # 检查是否已有同名 issue
            ISSUE_NUMBER=$(gh issue list --state all --search "$TITLE in:title" --json number,title | jq -r ".[] | select(.title==\"$TITLE\") | .number")
            echo "🔍 检查是否已有同名 issue: '$TITLE'，找到 issue number: $ISSUE_NUMBER"

            # 如果找到 issue，则更新，否则创建新的 issue
            if [[ -n "$ISSUE_NUMBER" ]]; then
              echo "♻️ 更新已存在的 issue #$ISSUE_NUMBER"
              
              # 更新issue内容
              gh issue edit "$ISSUE_NUMBER" --body-file /tmp/issue_body.md
              
              # 首先移除所有标签
              CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels | jq -r '.labels[].name')
              if [[ -n "$CURRENT_LABELS" ]]; then
                echo "🏷️ 移除现有标签..."
                for current_label in $CURRENT_LABELS; do
                  gh issue edit "$ISSUE_NUMBER" --remove-label "$current_label"
                done
              fi
              
              # 添加新标签
              echo "🏷️ 添加新标签..."
              for label in "${LABEL_ARRAY[@]}"; do
                gh issue edit "$ISSUE_NUMBER" --add-label "$label"
              done
            else
              echo "🆕 创建新的 issue: $TITLE"
              
              # 创建一个临时文件包含标签参数
              LABEL_PARAMS=""
              for label in "${LABEL_ARRAY[@]}"; do
                LABEL_PARAMS+=" --label \"$label\""
              done
              
              # 使用body-file和标签创建issue
              eval "gh issue create -t \"$TITLE\" --body-file /tmp/issue_body.md $LABEL_PARAMS"
            fi

            echo "✅ 完成：$TITLE"
          done < "${{ env.ISSUES_FILES_LIST }}"